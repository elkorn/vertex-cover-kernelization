\section{Wykorzystane techniki i technologie}\label{ss_internals-technologies}
W przeciągu ostatniej dekady proces tworzenia oprogramowania uległ znaczącym
transformacjom.
Ogromna popularyzacja sektora technologii informacyjnych, którą zawdzięczamy
głównie rozwojowi internetu, przyczyniła się do skupienia dużo większej uwagi na
kwestiach zarówno sposobów wytwarzania oraz charakteru oprogramowania jak i na
narzędziach temu służących.

W środowisku informatyki biznesowej odchodzi się od klasycznych, liniowych
procesów tworzenia oprogramowania na rzecz szerokiego grona rozwiązań 
zaliczanych do grupy tzw. metodyk zwinnych. 
Głównym celem każdej metodyk zwinnych jest zwiększenie ilości dostarczanych 
produktów (w tym wypadku rozwiązań informatycznych) w danym czasie, zachowując 
jednocześnie jak najwyższy poziom ich jakości.
Prawidłowo wdrożone metodyki zwinne pozwalają na zacieśnienie pętli
komunikacyjnej pomiędzy interesariuszami biznesowymi oraz technicznymi projektów,
owocując częstszą wymianą bardziej szczegółowych informacji.
Bezpośrednio przekłada się to na zwiększoną przezroczystość procesu realizacji projektu.
Konsekwencja ta otwiera nowe pole możliwości związanych z planowaniem, podziałem prac,
raportowaniem i prognozowaniem postępów prac oraz weryfikacją prognoz poprzez 
monitorowanie stanu realizacji za pośrednictwem metryk.

Zwiększona częstotliwość dostarczania wartości biznesowej wiąże się z potrzebą
wynajdowania bardziej nowoczesnych narzędzi wspierających taki tryb działania.

Termin ``narzędzia'' jest obecnie niezwykle pojemny.

n the last half decade or so, I have noticed four major trends in programming languages. These trends, from once niche paradigms going mainstream to truly innovative ways of writing code, have an impact on our way of thinking, on our way of working and on the future for years to come (or so I believe). Without further ado…

Functional Programming
Functional programming has been around since forever (well, since the 1950's at least) but only recently has it been gaining a foothold in the mainstream with such languages as C#, Java and even C++ adding powerful functional constructs to the core language.

More importantly, true functional programming languages are gaining a foothold in the mainstream with Scala, Clojure and Haskell being prominent examples. We may yet see a day where hybrid languages like Scala or F# will dominate the market.

Systems Programming
Systems programming seems rather old fashioned in this Web-centric age where C is reserved for kernel hackers and database developers, not the average programmer. Even so, some truly innovative ideas have come out of the systems programming field with such languages as Go, Rust and D becoming popular for their hybrid approaches — modern object-orientation and high level library routines, coupled with mixed manual/automatic memory management. This hybrid approach is, in all probability, the future of systems programming.

Concurrent Programming
Concurrent programming has always been a pain. Synchronizing threads at a low abstraction level, even more so. Because of this, many modern languages heavily feature high-level concurrency primitives with the canonical examples being Erlang and Go with their message passing and channel abstractions. C# also does very well with it’s task library and async/await, not to mention Javascript and callbacks/deferreds. If is now expected of any modern language to contain such high level concurrency primitives.

Compile-to-JS
This trend goes hand in hand with moving as much of the application as possible to the client-side. This has caused a great increase in demand for the dual needs of speed of coding and speed of execution. This has created such languages as CoffeeScript (Javascript — but better, targeting speed of coding) and asm.js (Super optimizable subset of Javascript, targeting speed of execution). With asm.js positioning itself as a compile target instead of regular Javascript, we’ll have powerfull languages like CoffeeScript (and TypeScript, and ClojureScript and others) compile to high performing asm.js and then off to native code.

Further Development
Currently, nobody knows, least of all me, what will happen with all these trends. I will allow myself a small prediction — those who will adapt, will thrive. Javascript and C# are shining examples of languages that grab whatever new idea is becoming hot and implement it in a mainstream friendly way. Languages like Scala and Go will have their niche but when people will look for the Swiss army knife of languages, they’d probably be off the list.


\subsection{Język programowania Go} % (fold)
\label{sss_go}


% subsection go (end)