\subsection{Opis wybranych pakietów}\label{ss_internals_important_packages}
\subsubsection{\textbf{Pakiet \texttt{graph}}}
\par{
  W obliczu charakterystyki pracy to znaczy podjęcia się analizy i implementacji szerokiej gamy technik związanych z parametryzacją złożoności obliczeniowej pokrycia wierzchołkowego, kwestią wymagającą uwagi jest sposób reprezentacji grafu.
  W związku ze zróżnicowaniem podejść do problemu, reprezentacja struktur grafowych za pomocą wyłącznie macierzy incydencji lub też listy incydencji okazuje się nie tyle niewystarczająca, co nieoptymalna.
  Podczas gdy niektóre z technik operują na grafie przede wszystkim za pomocą wierzchołków (głównie metody oparte na sformułowaniu problemu jako egzemplarza przepływu w sieci), inne zdecydowanie traktują graf jako zbiór krawędzi pomiędzy pewnymi punktami.
  Jako iż jednym z pomniejszych celów pracy jest stworzenie ogólnej platformy użytecznej do testowania rozwiązań różnych problemów związanych z grafami, zdecydowano się zaimplementować strukturę grafu jako reprezentację zawierającą zarówno macierz incydencji jak i listę krawędzi.
}
\par{
  \begin{lstlisting}[language=go, caption=Typy reprezentujące wierzchołki grafu.]
  type Vertex int
  type Vertices []Vertex
  \end{lstlisting}
  W celu uniknięcia potrzeby uważania tablicy haszujących, gdzie klucze stanowią wierzchołki, zdecydowano się na wprowadzenie metody \textss{\lstinline{Vertex.ToInt() int}}, konwertującej dowolny wierzchołek do odpowiadającej mu wartości całkowitoliczbowej.
  Zabieg ten pozwala na zastosowanie zwykłych tablic w miejsce tablic haszujących, co pozwala na obniżenie złożoności obliczeniowej związanych z takimi strukturami operacji.

  Wartości wierzchołków często występują obok liczb całkowitych, pełniących zazwyczaj w tym kontekście rolę indeksów tablic.
  Aby łatwiej było odróżnić egzemplarze wierzchołków od zwykłych liczb całkowitych, przyjęto konwencję numeracji wartości wierzchołków grafu od 1.
  \begin{lstlisting}[language=go, caption=Typy reprezentujące krawędzie grafu.]
  type Edge struct {
    From      Vertex
    To        Vertex
    isDeleted bool
  }

  type Edges []*Edge
  \end{lstlisting}

  Krawędzie grafu nie są reprezentowane idiomatycznie, to znaczy jako pary wierzchołków stanowiących ich zakończenia.
  Wynika to z praktycznej potrzeby związanej ze zwijaniem krawędzi w ramach operacji przetwarzania wstępnego (podrozdział~\ref{Section_preprocessing}), działania algorytmu Edmondsa (podrozdział~\ref{ss_edmonds_blossom}) oraz algorytmu Chen, Kanj, Xia (podrozdział~\ref{s_chen_kanj_xia}).
  Praktyka pokazuje, iż znacznie łatwiejsze i bardziej wydajne jest oznaczanie krawędzi grafu jako usuniętych zamiast właściwego ich usuwania --- głównie ze względu na fakt, iż w większości przypadków zostają one w późniejszym momencie przywrócone do grafu na przykład w celu określenia pełnej postaci odnalezionej ścieżki powiększającej.

  \begin{lstlisting}[language=go, caption=Struktura reprezentująca graf.]
  type Graph struct {
    Vertices                Vertices
    Edges                   Edges
    CurrentVertexIndex      int
    IsVertexDeleted         []bool
    degrees                 []int
    neighbors               [][]*Edge
    numberOfVertices        int
    numberOfEdges           int
    isRegular               bool
    needToComputeRegularity bool
  }
  \end{lstlisting}

  Podczas implementacji rozwiązań opisywanych w niniejszej pracy problemów napotkano na trzy podstawowe sposoby poruszania się po grafie.
  Każdy z tych sposobów znajduje odzwierciedlenie w implementacji struktury --- istnieje metoda realizująca dany sposób przy zachowaniu najmniejszej możliwej złożoności dla grafu $G=(V, E)$: $O(1)$, $O(|V|)$, lub $O(|E|)$.
  \\\\\underline{Iteracja po wszystkich wierzchołkach}\\
  \par{
      Metoda \textss{\lstinline{ForAllVertices(action func(v Vertex, chan<- done bool))}} iteruje po kolekcji \textss{\lstinline{Vertices}}, zapewniając  podstawową złożoność operacji na poziomie $O(|V|)$, z wyłączeniem złożoności operacji realizowanych przez funkcję \textss{\lstinline{action}}. Kanał \textss{\lstinline{done}} służy do informowania o potrzebie przerwania iteracji.\\
      Metody \textss{\lstinline{ForAllVerticesOfDegree(degree int, action func(v Vertex, chan<- done bool))}} oraz \textss{\lstinline{ForAllVerticesOfDegreeGeq(degree int, action func(v Vertex, chan<- done bool))}} korzystają z metody \textss{\lstinline{ForAllVertices}}, nakładając dodatkowe ograniczenia związane ze stopniem wierzchołków, które mają zostać uwzględnione w iteracjach.
  }
  \\\\\underline{Iteracja po wszystkich krawędziach}\\\
  \par{
      Analogicznie jak w przypadku wierzchołków, metoda \textss{\lstinline{ForAllEdges(action func(edge *Edge, done chan<- bool))}} iteruje po kolekcji \textss{\lstinline{Edges}}, zachowując złożoność operacji na poziomie $O(E)$ z wyłączeniem złożoności funkcji \textt{action}.
  }
  \\\\\underline{Uzyskiwanie dostępu do krawędzi pomiędzy danymi wierzchołkami}\\
  \par{
      Metoda \textss{\lstinline{GetEdgeByCoordinates(from, to int) *Edge}} korzysta z macierzy incydencji \textss{\lstinline{neighbors}}, pobierając z niej krawędź łączącą wierzchołki, których wartości skonwertowane do liczb całkowitych odpowiadają podanym współrzędnym.

      Przy okazji omawiania tejże metody należy zwrócić uwagę na następujące dwie kwestie.
      \begin{enumerate}
        \item Macierz incydencji \textss{\lstinline{neighbors}} zamiast wartości logicznych typu \textss{\lstinline{bool}} zawiera wskaźniki na krawędzie istniejące w kolekcji \textss{\lstinline{Edges}}.
        Rozwiązanie to podyktowane jest znów praktyką --- w zdecydowanej większości przypadków fakt istnienia danej krawędzi wiązał się z potrzebą wykonania działań z nią związanych, gdzie przechowywanie wskaźników na krawędzie pozwoliło na uniknięcie dodatkowych jawnych odwołań do kolekcji \textss{\lstinline{Edges}}.
        \item W związku z faktem, iż w ramach niniejszej pracy podjęto się analizy rozwiązań wersji problemów dotyczących grafu o nieskierowanych krawędziach, macierz \textss{\lstinline{neighbors}} zawiera wskaźnik do tej samej krawędzi zarówno dla współrzędnych wprost $(x, y)$, jak i zestawu transponowanego $(y, x)$.
        Rozwiązanie takie zostało przyjęte, mimo pewnego narzutu zajętości pamięci, za pożądane głównie ze względu na spójność właściwej struktury grafu z jego logiczną reprezentacją.
        Dodatkowo, zachowanie takiego rozłożenia wskaźników pomaga w bardziej zrozumiały sposób posługiwać się strukturą sieci przepływowej.
      \end{enumerate}
  }
  \\\\\underline{Operacje wykonywane na zbiorze wierzchołków sąsiednich}\\
  \par{
    Bardzo szeroki zakres działań implementowanych algorytmów w grafie $G=(V,E)$ opiera się na operacjach wykonywanych na sąsiedztwie wierzchołka $N(v); v \in V$.
    Zdecydowanie najczęściej realizowana jest iteracja po wierzchołkach sąsiednich, na drugim miejscu znajdują się operacje wymagające uzyskania sąsiedztwa jako kolekcji lub zbioru w rozumieniu struktury danych.
    W tym celu bardzo pomocna okazuje się macierz incydencji.
    Dla pierwszego przypadku została zaimplementowana metoda \textss{\lstinline{ForAllNeigbors(v Vertex, action func(edge *Edge, done chan<- bool))}}, oparta na rozumowaniu analogicznym do tego, na którym oparto metodę \textss{\lstinline{ForAllEdges}}, jednak iterująca po danym rzędzie macierzy \textss{\lstinline{neighbors}}, indeksowanym przekształconą do liczby całkowitej wartością wierzchołka $v$ z ograniczeniem uwzględniania w iteracjach wyłącznie istniejących wskaźników (to znaczy \textt{edge != nil}).

    Drugi przypadek obsługiwany jest przez metody \textss{\lstinline{GetNeighbors(v Vertex) Neighbors}} oraz \textss{\lstinline{GetNeighborsWithSet(v Vertex) (Neighbors, mapset.Set)}}.

    Metoda \textss{\lstinline{GetNeighbors}} zwraca odpowiedni rząd macierzy incydencji opakowany w typ pomocniczy, natomiast metoda \textss{\lstinline{GetNeighborsWithSet}} dodatkowo w ramach wewnętrznej iteracji konstruuje zbiór wierzchołków (w rozumieniu struktury danych) stanowiących sąsiedztwo.
    Wszystkie opisane metody związane z operacjami na sąsiedztwie wierzchołka $v$ zachowują złożoność $O(|N(v)|)$ z wyłączeniem złożoności funkcji \textss{\lstinline{action}}.
  }
}
\subsubsection{\textbf{Pakiet \texttt{vc} --- algorytm \texttt{BranchAndBound}}}
\label{ss_internals_BnB}
\par{
  W celu weryfikacji poprawności działania implementacji koncepcji związanych z redukcją dziedziny do jądra problemu pokrycia wierzchołkowego opisanych w podrozdziale~\ref{s_kernelization} wymagane jest zaimplementowanie algorytmu rozwiązującego sam problem pokrycia wierzchołkowego.

  W podrozdziale~\ref{s_vertex_cover_domain} przytoczono prosty, rekurencyjny algorytm siłowy służący do tego celu.
  Jednak w związku z prominencją koncepcji drzewa poszukiwań z ograniczeniami w dziedzinie parametrycznej złożoności obliczeniowej oraz zainteresowaniem technikaliami tej koncepcji, podjęto decyzję o stworzeniu własnego algorytmu na niej opartego, o potencjalnie mniejszej złożoności obliczeniowej od wersji naiwnej przez podążanie wyłącznie za obiecującymi gałęziami poszukiwań.

  \begin{definition}
    Mianem \emph{rozwiązania kandydackiego} w grafie $G=(V, E)$ określa się zbiór wierzchołków $C=\{v_1, v_2, \ldots\, v_p\} \neq \emptyset; C \subseteq V$ spełniający warunki częściowego pokrycia wierzchołkowego.
  \end{definition}
  \begin{definition}\thlabel{def_bnb_promising_solution}
    W grafie $G=(V,E)$ dla drzewa poszukiwań $T$ z pewnym najlepszym rozwiązaniem kandydackim $r_b$ mianem \emph{obiecującego} rozwiązania określa się rozwiązanie kandydackie $r$ spełniające jedną z następujących własności w podanej kolejności.
    \begin{enumerate}
      \item Liczba krawędzi w zbiorze $E$ pokrytych przez rozwiązanie $r$ jest większa niż liczba krawędzi w zbiorze $E$ pokrytych przez obecne najlepsze rozwiązanie $r_b$.
      \item Liczba krawędzi w zbiorze $E$ pokrytych przez rozwiązanie $r$ jest równa liczbie krawędzi w zbiorze $E$ pokrytych przez obecne najlepsze rozwiązanie $r_b$ i liczebność rozwiązania $|r|$ jest mniejsza od liczebności obecnego najlepszego rozwiązania $|r_b|$.
    \end{enumerate}
  \end{definition}
  \begin{definition}
     W grafie $G=(V, E)$ dla drzewa poszukiwań $T$ z pewnym obiecującym rozwiązaniem $r_b$ Mianem \emph{obiecującej gałęzi} określa się gałąź $t \subseteq T$ zawierającą obiecujące rozwiązanie $r_b$.
  \end{definition}
}
\par{
  Algorytm działa zgodnie z następującym pseudokodem.
  Zmienna $Q$ stanowi kolejkę priorytetową działającą według własności określanych Definicją~\ref{def_bnb_promising_solution}.
  \begin{algorithm}
    \caption{Algorytm odnajdujący pokrycie wierzchołkowe --- drzewo poszukiwań z ograniczeniami}\label{alg_VC2}
    \begin{algorithmic}[1]
      \Function{BranchAndBoundVC}{G, k}

        \algorithmicrequire{graf $G=(V, E)$, maks. rozmiar pokr. wierzch. $k$}

        \algorithmicensure{odnalezione pokrycie wierzchołkowe}

        \State $Q \gets \emptyset$\Comment{Q --- kolejka priorytetowa}
        \State $VS \gets \Call{Wierzchołki}{E}$\Comment{Zbiór wierzchołków krawędzi grafu G}
        \State{Wstaw $\emptyset$ do $Q$}
        \State $b \gets \infty$
        \While{$Q \neq \emptyset$}
          \State{$r \gets$ kolejne rozwiązanie z $Q$}
          \If{$r$ jest obiecujące względem $b$}
            \If{$r$ pokrywa wszystkie krawędzie w $G$}
            \State {$b \gets \min\{|r_{VC}\supseteq r|\}$ takiego, że $r_{VC}$ zawiera pokrycie wierzch.}
            \If{$b \leq k$}
              \State{\textbf{return} $r$}
            \EndIf
            \Else
              \For{$v \in VS$}\label{bnb_forLoop}
                \If{$v \in r$}
                  \State{Idź do kroku~\ref{bnb_forLoop}}
                \EndIf
                \State$r_{tmp} \gets r \cup \{v\}$
                \If{$r_{tmp}$ jest obiecujące względem $b$}
                  \State{Wstaw $r_{tmp}$ do $Q$}
                \EndIf
              \EndFor
            \EndIf
          \EndIf
        \EndWhile
        \State{\textbf{return nil}}\Comment{Nie istnieje pokrycie o liczebności $\leq k$}
      \EndFunction
    \end{algorithmic}
  \end{algorithm}
  \[
    \textbf{TODO: Write about the complexity after you test it.}
  \]

\subsubsection{\textbf{Pakiet \texttt{kernelization} --- algorytm Chen, Kanj, Xia}}
\label{sss_internals_ckx}
\begin{algorithm}
  \caption{Algorytm strukturyzacji}\label{alg_ckx_struction}
  \begin{algorithmic}[1]
  \Function{Struction}{G}

    \algorithmicrequire{graf wejściowy $G=(V, E)$}

    \algorithmicensure{graf strukturyzowany $G^\prime=(V^\prime, E^\prime)$}

    \State $v_0 \gets v \in V$
    \State $p \gets |N(v_0)|$
    \State $G^\prime \gets G$
    \State $V^\prime \gets V \setminus N(v_0)$
    \For{każda antykrawędź $\{v_i, v_j\} \in V; 0 < i < j \leq p$}
      \State $V^\prime \gets V^\prime \cup \{v_{ij}\}$\Comment{wstaw nowy wierzchołek do grafu strukturyzowanego}
    \EndFor
    \For{każda krawędź}
    \EndFor
  \EndFunction
  \end{algorithmic}
\end{algorithm}